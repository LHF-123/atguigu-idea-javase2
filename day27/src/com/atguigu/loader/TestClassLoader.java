package com.atguigu.loader;

/*
 *  类的加载：
 *  1、加载
 *  2、连接
 *  （1）校验：其中一项看字节码文件的数据是否以魔数“cafe”开头
 *          以及当前的JVM的运行的JDK版本是否可以运行该字节码的数据。例如：JDK 1.8可以运行JDK 1.7编译的字节码，反过来不行。
 *  （2）准备
 *          给成员变量（类变量/静态变量）赋默认值
 *          把常量（final）等值在方法区的常量池中给准备好。
 *  （3）解析
 *          虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程
 *      理解把类中的对应的类型名换成  该类型的Class对象的地址
 *      String  -->     String类型对应的Class地址
 *
 *  3、初始化<clinit>类初始化
 *
 *  <clinit>类初始化由两部分组成：
 *  （1）静态变量的显式初始化代码，赋值代码
 *  （2）静态代码块
 *      （1）和（2）的顺序从上往下
 *
 *  当一个类初始化时，发现他的父类如果没有初始化，会先初始化父类。
 *  每一个类只会初始化一次，并且类初始化的过程是安全的。
 *
 *  只是面试用。
 *  哪些操作会导致类的初始化？
 *      这句话的意思是，类的加载不一定就会发生类的初始化。虽说大多数时候，在类的加载时就直接初始化了。
 *  （1）main方法所在的类在加载，就直接先初始化了
 *  （2）new一个类的对象，一定会先完成类的初始化
 *  （3）调用该类的静态变量（final的常量除外）和静态方法
 *  （4）使用java.lang.reflect包的方法对类进行反射调用
 *  （5）当初始化一个类，如果其父类没有被初始化。则会先初始化他的父类
 *
 *  哪些情况不会导致类的初始化？
 *  （1）引用静态常量（final）不会触发此类的初始化
 *  （2）当访问一个静态域时，只有真正声明这个域的类才会被初始化
 *      换句话说，通过子类访问父类静态域时，只会初始化父类，不会初始化子类
 *  （3）通过数组定义类引用，不会触发此类的初始化（下面的代码就是）
 *
 */
public class TestClassLoader {
    public static void main(String[] args) {
        MyClass[] arr = new MyClass[5];//只是创建了数组对象，没有Class的对象。不会导致类初始化
        //数组对象的类型 MyClass[]
        //数组元素的类型 MyClass

        System.out.println(arr.getClass());//class [Lcom.atguigu.loader.MyClass;
    }
}
class MyClass {
    static {
        System.out.println("静态代码块");
    }
}